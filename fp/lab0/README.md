# Почему **OCaml** для курса по ФП

- **Строгая типизация с выводом типов.** Компилятор ловит целые классы ошибок ещё до запуска → меньше рантаймов и надёжнее код.
- **Алгебраические типы (ADT) и pattern matching.** Удобно описывать варианты и писать "ветки" как явные случаи вместо длинных `if/else`.
- **Быстрые нативные бинарники и мгновенный старт.** Для утилит и инструментов это ощутимый профит по сравнению с тяжёлыми рантаймами.
- **Строгие вычисления по умолчанию.** В Haskell ленивые вычисления по умолчанию усложняют прогнозирование производительности и профилирование; в OCaml поведение проще держать под контролем.

---

## Стек инструментов

- **opam** — зависимости и версии OCaml  
- **dune** — сборка/запуск/тесты  
- **ocamlformat** — автоформат кода  
- **QCheck / alcotest** — property-based и юнит-тесты

---

## ЛР-4: мини-библиотека парсер-комбинаторов

**Что делаю:** свою небольшую библиотеку парсер-комбинаторов и на её основе два парсера:

1. **JSON-парсер**
2. **Потоковый CSV-парсер** (чтение стримом, без загрузки всего файла в память)

**Почему OCaml подходит:** строгая типизация ловит ошибки на компиляции, логика ветвлений естественно пишется через pattern matching.  
**Ожидаемый результат:** два быстрых CLI-инструмента, которые легко тестировать.

---

## Книга для изучения

- *Разработка программ с помощью Objective Caml* — Emmanuel Chailloux, Pascal Manoury, Bruno Pagano (18 мая 2007)

---

## Материалы для эссе и подготовки

- https://markkarpov.com/post/haskell-vs-ocaml  
- https://sanette.github.io/ocaml2.org/learn/description.html  
- https://habr.com/ru/articles/108529/  
- https://habr.com/ru/articles/152889/
